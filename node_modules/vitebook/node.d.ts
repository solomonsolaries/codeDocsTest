/// <reference types="node" />
/// <reference types="urlpattern-polyfill" />

import type { ConfigEnv } from 'vite';
import { ConfigFunction } from '@markdoc/markdoc';
import type { FilterPattern } from '@rollup/pluginutils';
import type { HighlighterOptions } from 'shiki';
import kleur from 'kleur';
import { Manifest } from 'vite';
import { default as Markdoc } from '@markdoc/markdoc';
import { Config as MarkdocConfig } from '@markdoc/markdoc';
import { Node as MarkdocNode } from '@markdoc/markdoc';
import { RenderableTreeNode as MarkdocRenderableTreeNode } from '@markdoc/markdoc';
import { RenderableTreeNodes as MarkdocRenderableTreeNodes } from '@markdoc/markdoc';
import { Tag as MarkdocTag } from '@markdoc/markdoc';
import { NodeType } from '@markdoc/markdoc';
import { Options } from 'hast-util-to-html';
import ora from 'ora';
import type { OutputAsset } from 'rollup';
import type { OutputBundle } from 'rollup';
import type { OutputChunk } from 'rollup';
import { Plugin as Plugin_2 } from 'vite';
import type { ResolvedConfig } from 'vite';
import { Schema } from '@markdoc/markdoc';
import { URLPatternComponentResult as URLPatternComponentResult_2 } from 'urlpattern-polyfill/dist/types';
import type { UserConfig } from 'vite';
import type { ViteDevServer } from 'vite';

export declare type App = AppDetails & {
    /** Plugin extensions. */
    [x: string]: unknown;
    context: Map<string, unknown>;
    nodes: AppNodes;
    markdoc: MarkdocSchema;
    disposal: DisposalBin;
    logger: typeof logger;
    vite: {
        env: ConfigEnv;
        user: UserConfig;
        /** Available after core plugin `configResolved` hook runs. */
        resolved?: ResolvedConfig;
        /** Available during dev mode after core plugin `configureServer` hook runs. */
        server?: ViteDevServer;
    };
    destroy: () => void;
};

export declare type AppConfig = Omit<Partial<ResolvedAppConfig>, 'build' | 'dirs' | 'client' | 'markdown' | 'routes' | 'sitemap' | 'isBuild' | 'isSSR'> & {
    /** Application build options. */
    build?: BuildConfig;
    /** Application directory paths. */
    dirs?: DirectoriesConfig;
    /** Client options. */
    client?: ClientConfig;
    /** Routes options. */
    routes?: RoutesConfig;
    /** Markdown options. */
    markdown?: MarkdownConfig;
    /** One or many sitemap configurations. */
    sitemap?: SitemapConfig | SitemapConfig[];
};

export declare type AppContextMap = Map<string, unknown>;

export declare type AppDetails = {
    version: string;
    dirs: AppDirectories;
    entry: {
        client: string;
        server: string;
    };
    vite: {
        env: ConfigEnv;
    };
    config: ResolvedAppConfig;
};

export declare type AppDirectories = {
    cwd: Directory;
    root: Directory;
    workspace: Directory;
    app: Directory;
    tmp: Directory;
    build: Directory;
    client: Directory;
    server: Directory;
    public: Directory;
};

export declare type AppFactory = AppDetails & {
    create: () => Promise<App>;
};

export declare class AppNodes {
    pages: PageNodes;
    layouts: LayoutNodes;
    endpoints: EndpointNodes;
    markdoc: MarkdocNodes;
    init(app: App): Promise<void>;
    clear(): void;
    protected _resolvePageLayouts(): void;
}

export declare type AutoBuildAdapterConfig = {
    use?: 'static' | 'vercel';
    vercel?: VercelBuildAdapterConfig;
};

export declare type BuildAdapter = {
    name: string;
    /** Started loading data for page (includes any layouts). */
    startLoadingPage?(pathname: string, page: ServerPage): void | Promise<void>;
    /** Finished loading data for page (includes any layouts). */
    finishLoadingPage?(pathname: string, page: ServerPage, data: ServerLoadedOutputMap, redirect?: string): void | Promise<void>;
    startRenderingPages?(): void | Promise<void>;
    startRenderingPage?(pathname: string, page: ServerPage): void | Promise<void>;
    finishRenderingPage?(pathname: string, page: ServerPage, result: {
        redirect?: {
            path: string;
            statusCode: number;
        };
        ssr?: ServerRenderResult | null;
        dataAssetIds?: Set<string>;
    }): void | Promise<void>;
    finishRenderingPages?(): void | Promise<void>;
    /** Build data is ready and can be used to write to file system. */
    write?(): void | Promise<void>;
    close?(): void | Promise<void>;
};

export declare type BuildAdapterFactory = (app: App, bundles: BuildBundles, build: BuildData, utils: BuildAdapterUtils) => BuildAdapter | Promise<BuildAdapter>;

export declare type BuildAdapterUtils = {
    logger: typeof logger;
    color: typeof kleur;
    icons: {
        info: string;
        tip: string;
        success: string;
        warn: string;
        error: string;
    };
    crawl(html: string): string[];
    hash(content: string): string;
    normalizePath(path: string): string;
    normalizeURL(url: URL): URL;
    mkdirp(dirname: string): void;
    rimraf(dirname: string): void;
    readFile(filePath: string): Promise<string>;
    writeFile(filePath: string, fileContent: string): Promise<void>;
    createFilesArray(): {
        filename: string;
        content: string;
    }[];
    writeFiles: (files: {
        filename: string;
        content: string;
    }[], resolveFilePath: (filename: string) => string, resolvePendingMessage: (filesCount: string) => string, resolveSuccessMessage: (filesCount: string) => string) => Promise<void>;
    copyFile(src: string, dest: string): void;
    copyDir(src: string, dest: string): void;
    ensureFile(filePath: string): Promise<void>;
    ensureDir(dirname: string): Promise<void>;
    noslash(path: string): string;
    slash(path: string): string;
    endslash(path: string): string;
    noendslash(path: string): string;
    isLinkExternal(path: string): boolean;
    createSpinner: typeof ora;
    pluralize(word: string, count: number): string;
    resolveHTMLFilename(url: string | URL): string;
    resolveDataFilename(name: string): string;
    resolvePageChunks(page: ServerPage, modules?: Set<string>): {
        assets: string[];
        imports: string[];
        dynamicImports: string[];
    };
    buildSitemaps(): Promise<[filename: string, content: string][]>;
    createRedirectMetaTag(url: string): string;
    createLinkTag(rel: string, pathname: string): string;
    createPreloadTag(pathname: string): string;
    createDataScriptTag(dataAssetIds: Set<string>): string;
    guessPackageManager(): 'npm' | 'pnpm' | 'yarn';
    findPreviewScriptName(): Promise<string | null | undefined>;
    logBadLinks: () => void;
    logRoutes(overrides?: {
        level?: RoutesLogLevel;
        style?: RoutesLogStyle;
    }): void;
    escapeHTML(content: string): string;
    createDirectory: (dirname: string) => Directory;
    getHTMLTemplate(): string;
};

export declare type BuildBundles = {
    entries: Record<string, string>;
    client: {
        output: OutputBundle;
        entryChunk: OutputChunk;
        appChunk: OutputChunk;
        appCSSAsset?: OutputAsset;
        chunks: OutputChunk[];
        assets: OutputAsset[];
        /**
         * Vite manifest that can be used to build preload/prefetch directives. The manifest contains
         * mappings of module IDs to their associated chunks and asset files.
         *
         * @see {@link https://vitejs.dev/guide/ssr.html#generating-preload-directives}
         */
        viteManifest: Manifest;
    };
    server: {
        output: OutputBundle;
        chunks: OutputChunk[];
    };
};

export declare type BuildConfig = Partial<ResolvedBuildConfig>;

export declare type BuildData = {
    /**
     * Application entry files that are passed to Rollup's `input` option.
     */
    entries: Record<string, string>;
    /**
     * Valid links and their respective server page that were found during the build process.
     */
    links: Map<string, ServerPage>;
    /**
     * Map of invalid links that were either malformed or matched no route pattern during the build
     * process. The key contains the bad URL pathname.
     */
    badLinks: Map<string, {
        page?: ServerPage;
        reason: string;
    }>;
    /**
     * Redirects object where the keys are the URL pathname being redirected from.
     */
    redirects: Map<string, {
        /** The URL pathname being redirected from. */
        from: string;
        /** The URL pathname being redirected to. */
        to: string;
        /** The redirect HTML file name which can be used to output file relative to build directory. */
        filename: string;
        /** The HTML file content containing the redirect meta tag. */
        html: string;
        /** HTTP status code used for the redirect. */
        statusCode: number;
    }>;
    /**
     * Links and their respective server endpoint.
     */
    endpoints: Map<string, ServerEndpoint>;
    /**
     * Map of links (URL Pathname) and their respective loaded server output from calling the
     * page/layout `loader()`.
     */
    loaded: Map<string, {
        /** Map of data asset id to server loaded output object. */
        output: ServerLoadedOutputMap;
        /** Any redirect returned from the loaded output. */
        redirect?: ServerLoadedRedirect;
    }>;
    /**
     * Map of links (URL pathname) and their respective SSR rendered content and loaded data asset
     * IDs.
     */
    renders: Map<string, {
        /** The HTML file name which can be used to output file relative to build directory. */
        filename: string;
        /** The matching server page for this path. */
        page: ServerPage;
        /** The SSR results containing head, css, and HTML renders. */
        ssr: ServerRenderResult;
        /**
         * All data asset ID's that belong to this path. These can be used find matching records in
         * the `data` object.
         */
        dataAssetIds: Set<string>;
    }>;
    /**
     * JSON data that has been loaded by pages and layouts. The key is a unique data asset ID for the
     * given page/layouts combination. You can find data ID's in the `renders` map for each page.
     */
    data: Map<string, {
        /** The data JSON file name which can be used to output file relative to build directory. */
        filename: string;
        /** Loaded data. */
        data: Record<string, unknown>;
        /** The loaded data serailized (JSON.stringify). */
        serializedData: string;
        /** The data asset ID sha-1 hash. */
        idHash: string;
        /** The serialized content sha-1 hash. */
        contentHash: string;
    }>;
};

export declare function calcRoutePathScore(pathname: string): number;

export declare function checksumFile(algorithm: string, path: string): Promise<string>;

export declare function cleanRoutePath(pathname: string): string;

export declare const cleanUrl: (url: string) => string;

export declare type ClientConfig = Partial<ResolvedClientConfig>;

export declare type ClientLayout = {
    /** Layout name. */
    readonly name: string;
    /** System file path relative to `<root>`. */
    readonly rootPath: string;
    /** Layout module loader. Used to dynamically import client-side. */
    readonly loader: () => Promise<ClientLayoutModule>;
};

export declare type ClientLayoutModule = ClientPageModule;

export declare type ClientLoadedData = Record<string, unknown>;

export declare type ClientPage = {
    /** System file path relative to `<root>`. */
    readonly rootPath: string;
    /** Page route object. */
    readonly route: RouteInfo;
    /** Page file extension.  */
    readonly ext: string;
    /** Additional page metadata. */
    readonly context?: Record<string, unknown>;
    /** Page layout name. */
    readonly layoutName?: string;
    /** Page layouts identifiers. */
    readonly layouts: number[];
    /** Page module loader. Used to dynamically import page module client-side. */
    readonly loader: () => Promise<ClientPageModule>;
};

export declare type ClientPageModule = {
    readonly [id: string]: unknown;
    readonly default: unknown;
    readonly meta?: MarkdownMeta;
    readonly loader?: ServerLoader;
};

export declare function coalesceToError(err: any): Error;

export declare function comparePaths(pathA: string, pathB: string, { ordered }?: {
    ordered?: boolean | undefined;
}): number;

export declare function compareRoutes(routeA: RouteInfo, routeB: RouteInfo): number;

export declare type ComplexRouteMatcher = (route: string, info: {
    filePath: string;
}) => string | null | undefined | void;

export declare function copyDir(srcDir: string, destDir: string): void;

export declare function copyFile(src: string, dest: string): void;

export declare function createAutoBuildAdapter(config?: AutoBuildAdapterConfig): BuildAdapterFactory;

export declare const createError: (message?: string | undefined) => Error;

export declare function createStaticBuildAdapter(options?: {
    skipOutput?: boolean;
    skipRedirects?: boolean;
}): BuildAdapterFactory;

/**
 * `__dirname` alternative for ESM.
 */
export declare const currentDirectory: (meta: any) => string;

export declare type CustomRoutesLogger = (input: RoutesLoggerInput) => void | Promise<void>;

export declare const DATA_ASSET_BASE_PATH = "/_immutable/data";

export declare type DirectoriesConfig = Partial<ResolvedDirectoriesConfig>;

export declare type Directory = {
    /** Absolute path to directory. */
    path: string;
    /** Read contents of file relative to current directory. */
    read: (filePath: string) => string;
    /** Resolve file path relative to current directory. */
    resolve: (...path: string[]) => string;
    /** Resolve relative file path to current directory. */
    relative: (...path: string[]) => string;
    /** Write contents to file relative to current directory. */
    write: (filePath: string, data: string) => void;
};

export declare class DisposalBin {
    protected _disposal: (() => void | Promise<void>)[];
    add(...disposeCallbacks: (() => void | Promise<void>)[]): void;
    empty(): Promise<void>;
}

export declare function emptyDir(dir: string): Promise<void>;

export declare class EndpointNodes extends FileNodes<ServerEndpoint> {
    init(app: App, options?: FileNodesCallbacks<ServerEndpoint>): Promise<void>;
    add(filePath: string): Promise<ServerEndpoint>;
}

/**
 * Ensure a url `string` has an ending slash `/`.
 */
export declare const endslash: (str: string) => string;

export declare function ensureDir(dir: string): Promise<void>;

export declare function ensureFile(filePath: string): Promise<void>;

export declare function escapeHTML(str: string): string;

/**
 * Node CJS `require` equivalent for ESM.
 */
export declare const esmRequire: NodeRequire;

export declare function execRouteMatch<T extends RouteInfo>(url: URL, route?: T): URLPatternComponentResult_2 | undefined;

export declare const EXTERNAL_URL_RE: RegExp;

export declare abstract class FileNodes<T extends ServerFile> implements Iterable<T> {
    protected _app: App;
    protected _nodes: T[];
    protected _options: FileNodesOptions<T>;
    protected _filter: (id: string) => boolean;
    get size(): number;
    init(app: App, options: FileNodesOptions<T>): Promise<void>;
    protected _discover(): Promise<void>;
    protected _getRootPath(filePath: string): string;
    protected _getFilePaths(): string[];
    abstract add(filePath: string): Promise<T>;
    remove(filePath: string): number;
    getByIndex(index: number): T;
    find(filePath: string): T | undefined;
    findIndex(filePath: string): number;
    has(filePath: string): boolean;
    clear(): void;
    is(filePath: string): boolean;
    hasLoader(fileContent: string): boolean;
    resolveRoute(filePath: string): RouteInfo;
    toArray(): T[];
    [Symbol.iterator](): IterableIterator<T>;
}

export declare type FileNodesCallbacks<T> = {
    onAdd?: (node: T) => void;
    onRemove?: (index: number) => void;
};

export declare type FileNodesOptions<T> = FileNodesCallbacks<T> & {
    include: string[];
    exclude?: (string | RegExp)[];
};

/**
 * `upath` is normalizing paths to posix but messing up regex in filepath so they don't match by
 * converting `\` to `/`.
 */
export declare function fixRegexInPath(filePath: string): string;

/**
 * Format a date string to `yyyy-MM-dd`.
 */
export declare const formatDateString: (str: string, defaultDateString?: string) => string;

export declare function getRouteMatchingPathname(url: URL): string;

/**
 * Check if a given module is an esm module with a default export.
 */
export declare const hasDefaultExport: <T = unknown>(mod: unknown) => mod is {
    default: T;
};

export declare function hash(content: string): string;

export declare const HASH_RE: RegExp;

export declare type HighlightCodeBlock = (code: string, lang: string) => string | undefined | null;

export declare const inBrowser: boolean;

export declare function installPolyfills(): Promise<void>;

export declare function installURLPattern(): Promise<void>;

/**
 * Check if a value is an `array`.
 */
export declare function isArray(value: any): value is any[];

/**
 * Check if a value is a `boolean`.
 */
export declare function isBoolean(value: any): value is boolean;

export declare const isCommonJsFile: (filePath: string) => boolean;

/**
 * Check if a value is a `function`.
 */
export declare function isFunction(value: unknown): value is Function;

/**
 * Determine if a link is external or not.
 */
export declare const isLinkExternal: (link: string, base?: string) => boolean;

/**
 * Determine if a link is a http link or not.
 *
 * - http://github.com
 * - https://github.com
 * - //github.com
 */
export declare const isLinkHttp: (link: string) => boolean;

/**
 * Determine if a link is a `mailto` address or not.
 */
export declare const isLinkMailto: (link: string) => boolean;

/**
 * Determine if a link is a `tel` address or not
 */
export declare const isLinkTel: (link: string) => boolean;

export declare function isLoadedMarkdownPage(page: unknown): page is LoadedClientMarkdownPage;

export declare function isLoadedPage(page: unknown): page is LoadedClientPage;

/**
 * Check if a value is `null`.
 */
export declare function isNull(value: unknown): value is null;

/**
 * Check if a value is a `number`.
 */
export declare function isNumber(value: unknown): value is number;

/**
 * Check if a value is plain `object`.
 */
export declare const isObject: <T extends Record<any, any> = Record<any, any>>(val: unknown) => val is T;

export declare function isRoutePathDynamic(pathname: string): boolean;

/**
 * Check if a value is a `string`.
 */
export declare function isString(value: any): value is string;

export declare const isSubpath: (parent: string, filePath: string) => boolean;

export declare const isTypeScriptFile: (filePath: string) => boolean;

/**
 * Check if a value is `undefined`.
 */
export declare function isUndefined(value: unknown): value is undefined;

export declare const isWindows: boolean;

export declare class LayoutNodes extends FileNodes<ServerLayout> {
    init(app: App, options?: FileNodesCallbacks<ServerLayout>): Promise<void>;
    add(filePath: string): Promise<ServerLayout>;
    isOwnedBy(layout: string | ServerLayout, ownerFilePath: string, layoutName?: string): boolean | undefined;
    getOwnedLayoutIndicies(ownerFilePath: string, layoutName?: string): number[];
    protected _getName(filePath: string): string;
}

export declare type LoadedClientLayout = ClientLayout & {
    readonly $$loaded: true;
    readonly module: ClientLayoutModule;
    readonly default: unknown;
    readonly data: ClientLoadedData;
};

export declare type LoadedClientMarkdownPage = LoadedClientPage & {
    readonly meta: MarkdownMeta;
};

export declare type LoadedClientPage = Omit<ClientPage, 'layouts'> & {
    readonly $$loaded: true;
    readonly module: ClientPageModule;
    readonly default: unknown;
    readonly layouts: LoadedClientLayout[];
    readonly data: ClientLoadedData;
};

export declare const logger: {
    info: (title: string, ...args: unknown[]) => void;
    tip: (title: string, ...args: unknown[]) => void;
    success: (title: string, ...args: unknown[]) => void;
    warn: (title: string, ...args: unknown[]) => void;
    error: (title: string, ...args: unknown[]) => void;
    withSpinner: (pendingTitle: string, options?: {
        successTitle?: string;
        errorTitle?: string;
        timed?: boolean;
    }) => <T>(target: () => Promise<T>) => Promise<T>;
};

export declare const LoggerColor: Readonly<{
    Info: kleur.Color;
    Tip: kleur.Color;
    Success: kleur.Color;
    Warn: kleur.Color;
    Error: kleur.Color;
}>;

export declare const LoggerIcon: Readonly<{
    Info: "ℹ️";
    Tip: "💡";
    Success: "✅";
    Warn: "⚠️ ";
    Error: "🚨";
}>;

export declare function lowercaseFirstLetter(str: string): string;

export { Markdoc }

export declare type MarkdocAstTransformer = (data: {
    ast: MarkdocNode;
    filePath: string;
    source: string;
}) => void;

export { MarkdocConfig }

export declare type MarkdocContentTransformer = (data: {
    filePath: string;
    content: MarkdocRenderableTreeNode;
    frontmatter: MarkdownFrontmatter;
}) => string;

export declare type MarkdocFileNode = ServerFile & {
    type: 'node' | 'tag';
    name: string;
    cname: string;
    inline: boolean;
    routePath: string;
    owningDir: string;
};

export declare type MarkdocMetaTransformer = (data: {
    filePath: string;
    imports: string[];
    stuff: MarkdocTreeWalkStuff;
    meta: MarkdownMeta;
}) => void;

export { MarkdocNode }

export declare class MarkdocNodes extends FileNodes<MarkdocFileNode> {
    init(app: App, options?: FileNodesCallbacks<MarkdocFileNode>): Promise<void>;
    add(filePath: string): Promise<MarkdocFileNode>;
    isNode(filePath: string): boolean;
    isTag(filePath: string): boolean;
    isAnyNode(filePath: string): boolean;
    isOwnedBy(node: string | MarkdocFileNode, ownerFilePath: string): boolean | undefined;
    getOwnedNodes(ownerFilePath: string, type: '*' | 'node' | 'tag'): MarkdocFileNode[];
}

export declare type MarkdocOutputTransformer = (data: {
    filePath: string;
    code: string;
    imports: string[];
    stuff: MarkdocTreeWalkStuff;
    meta: MarkdownMeta;
}) => string;

export { MarkdocRenderableTreeNode }

export { MarkdocRenderableTreeNodes }

export declare type MarkdocRenderer = (data: {
    filePath: string;
    content: MarkdocRenderableTreeNode;
    imports: string[];
    stuff: MarkdocTreeWalkStuff;
    meta: MarkdownMeta;
}) => string;

export declare class MarkdocSchema {
    protected _app: App;
    protected _nodes: MarkdocNodes;
    /** track files for HMR. */
    hmrFiles: Map<string, Set<string>>;
    init(app: App): void;
    getOwnedConfig(ownerFilePath: string): MarkdocConfig;
    resolveOwnedImports(ownerFilePath: string): string[];
    protected _getOwnedNodesConfig(ownerFilePath: string): Partial<Record<NodeType, Schema<Readonly<Partial<{
    nodes: Partial<Record<NodeType, Schema<Readonly<Partial<any>>, string>>>;
    tags: Record<string, Schema<Readonly<Partial<any>>, string>>;
    variables: Record<string, any>;
    functions: Record<string, ConfigFunction>;
    partials: Record<string, any>;
    validation?: {
    validateFunctions?: boolean | undefined;
    } | undefined;
    }>>, string>>>;
    protected _getOwnedTagsConfig(ownerFilePath: string): Record<string, Schema<Readonly<Partial<{
    nodes: Partial<Record<NodeType, Schema<Readonly<Partial<any>>, string>>>;
    tags: Record<string, Schema<Readonly<Partial<any>>, string>>;
    variables: Record<string, any>;
    functions: Record<string, ConfigFunction>;
    partials: Record<string, any>;
    validation?: {
    validateFunctions?: boolean | undefined;
    } | undefined;
    }>>, string>>;
    protected _markFileForHMR(nodeFilePath: string, ownerFilePath: string): void;
}

export { MarkdocTag }

export declare type MarkdocTreeNodeTransformer = (data: {
    node: MarkdocRenderableTreeNode;
    stuff: MarkdocTreeWalkStuff;
}) => void;

export declare type MarkdocTreeWalkStuff = {
    [id: string]: any;
    baseUrl: string;
    filePath: string;
    appDir: string;
    links: Set<string>;
    imports: Set<string>;
    headings: MarkdownHeading[];
    highlight: HighlightCodeBlock;
};

export declare type MarkdownConfig = Partial<ResolvedMarkdownConfig>;

export declare type MarkdownFrontmatter = Record<string, any>;

export declare type MarkdownHeading = {
    level: number;
    title: string;
    id: string;
};

export declare type MarkdownMeta = {
    title?: string | null;
    headings: MarkdownHeading[];
    frontmatter: MarkdownFrontmatter;
    lastUpdated: number;
};

export declare function matchRoute<T extends RouteInfo>(url: URL, routes: T[] | {
    route: T;
}[]): WithRouteMatch<T> | undefined;

export declare function matchRouteInfo<T extends RouteInfo>(url: URL, routes: T[] | {
    route: T;
}[]): WithRouteMatch<{
    index: number;
    route: T;
}> | undefined;

export declare type MaybeServerLoadedOutput<Data = ServerLoadedData> = void | undefined | null | ServerLoadedOutput<Data>;

export declare function mkdirp(dir: string): void;

/**
 * Formats a number in milliseconds to a `string` with time units.
 *
 * @example '20.34ms'
 * @example '23s'
 * @example '2m'
 * @see https://github.com/vercel/ms
 */
export declare function ms(val: number): string;

/**
 * Remove ending slash `/` from a `string`.
 */
export declare const noendslash: (str: string) => string;

export declare function noop(): void;

export declare function normalizePath(id: string): string;

export declare function normalizeURL(url: URL): URL;

/**
 * Remove leading slash `/` from a `string`.
 */
export declare const noslash: (str: string) => string;

export declare class PageNodes extends FileNodes<ServerPage> {
    init(app: App, options?: FileNodesCallbacks<ServerPage>): Promise<void>;
    add(filePath: string): Promise<ServerPage>;
    getLayoutName(pageFilePath: string, fileContent?: string): Promise<string | undefined>;
}

export declare function parseDataAssetURL(url: URL): {
    url: URL;
    layoutIndex: number;
};

export declare type ParseMarkdownConfig = {
    ignoreCache?: boolean;
    filter: (id: string) => boolean;
    highlight: HighlightCodeBlock;
    transformAst: MarkdocAstTransformer[];
    transformTreeNode: MarkdocTreeNodeTransformer[];
    transformContent: MarkdocContentTransformer[];
    transformMeta: MarkdocMetaTransformer[];
    transformOutput: MarkdocOutputTransformer[];
    render: MarkdocRenderer;
};

export declare const prettyJsonStr: (obj: unknown) => string;

export declare const QUERY_RE: RegExp;

/**
 * vitejs/vite#610 when hot-reloading files, if we read immediately on the file change event
 * it can be too early and we sometimes get an empty buffer. Poll until the file's modified time
 * has changed before reading again.
 */
export declare function readRecentlyChangedFile(file: string): Promise<string>;

export declare type RenderMarkdocConfig = {
    attr?: (tagName: string, name: string, value: unknown) => string;
};

/**
 * Renders Markdoc to HTML tree.
 */
export declare function renderMarkdocToHTML(node: MarkdocRenderableTreeNodes, config?: RenderMarkdocConfig): string;

/**
 * `require.resolve` wrapper. Returns `null` if the module cannot be resolved instead of throwing
 * an error.
 */
export declare const requireResolve: (request: string) => string | null;

export declare function resolveAppConfig(root: string, { build, dirs, isDebug, client, routes, markdown, sitemap, }: AppConfig): ResolvedAppConfig;

export declare type ResolvedAppConfig = {
    /** Application build options. */
    build: ResolvedBuildConfig;
    /** Application directory paths. */
    dirs: ResolvedDirectoriesConfig;
    /** Client options. */
    client: ResolvedClientConfig;
    /** Routing options. */
    routes: ResolvedRoutesConfig;
    /** Markdown options. */
    markdown: ResolvedMarkdownConfig;
    /** Sitemap options. */
    sitemap: ResolvedSitemapConfig[];
    /** Whether app is running in debug mode. */
    isDebug: boolean;
    /** Whether Vite is in build mode. */
    isBuild: boolean;
    /** Whether Vite is in SSR mode. */
    isSSR: boolean;
};

export declare function resolveDataAssetID(pathname: string, layoutIndex?: number): string;

export declare type ResolvedBuildConfig = {
    adapter: BuildAdapterFactory | AutoBuildAdapterConfig;
};

export declare type ResolvedClientConfig = {
    /**
     * Application module ID or file path relative to `<root>`.
     */
    app: string;
    /**
     * Array of module ids that will be imported to configure the client-side application. The
     * module must export a `configureApp()` function.
     */
    configFiles: string[];
};

export declare type ResolvedDirectoriesConfig = {
    /**
     * Path to application directory. The value can be either an absolute file system path or a path
     * relative to `<root>`.
     *
     * @default '<root>/app'
     */
    app: string;
    /**
     * Directory to serve as plain static assets. Files in this directory are served and copied to
     * build dist dir as-is without transform. The value can be either an absolute file system path
     * or a path relative to `<app>`.
     *
     * @default '<app>/public'
     */
    public: string;
    /**
     * The build output directory. The value can be either an absolute file system path or a path
     * relative to `<root>`.
     *
     * @default '<root>/build'
     */
    build: string;
};

export declare type ResolvedMarkdownConfig = {
    /**
     * Filter files to be processed as Markdown files.
     */
    include: FilterPattern;
    /**
     * Filter files to be excluded from Markdown processing.
     */
    exclude: FilterPattern;
    /**
     * Markdoc configuration options.
     */
    markdoc: MarkdocConfig;
    /**
     * Markdoc nodes configuration.
     */
    nodes: {
        /**
         * Globs pointing at files which should be included as Markdoc nodes/tags.
         */
        include: string[];
        /**
         * Globs or RegExp indicating node files which should be excluded from being Markdoc nodes/tags.
         */
        exclude: (string | RegExp)[];
    };
    /**
     * Syntax highlighter configuration.
     *
     * - In order to use Shiki please install it `npm install shiki`.
     * - In order to use Starry Night please install it `npm install @woorm/starry-night`.
     *
     * @see {@link https://github.com/shikijs/shiki}
     * @see {@link https://github.com/wooorm/starry-night}
     */
    highlighter: 'shiki' | 'starry-night' | HighlightCodeBlock | false;
    /**
     * Shiki configuration options.
     */
    shiki: HighlighterOptions;
    /**
     * HAST to HTML transformer configuration. The tree returned from `starry-night` is a HAST
     * tree so it needs to be transformed to HTML - you can configure it here.
     *
     * @see {@link https://github.com/wooorm/starry-night}
     * @see {@link https://github.com/syntax-tree/hast-util-to-html}
     */
    hastToHtml: Options;
    /**
     * Markdoc AST transformers.
     */
    transformAst: ParseMarkdownConfig['transformAst'];
    /**
     * Called for each render node in the Markdoc renderable tree. This function can be used to
     * transform the tree before it's rendered.
     */
    transformTreeNode: ParseMarkdownConfig['transformTreeNode'];
    /**
     * Markdoc renderable tree transformers (_after_ AST is transformed into render tree).
     */
    transformContent: ParseMarkdownConfig['transformContent'];
    /**
     * Markdown meta transformers (_before_ content is rendered).
     */
    transformMeta: ParseMarkdownConfig['transformMeta'];
    /**
     * Rendered Markdown output transformers.
     */
    transformOutput: ParseMarkdownConfig['transformOutput'];
    /**
     * Custom Markdoc renderer which takes render tree and produces final output.
     */
    render?: ParseMarkdownConfig['render'];
};

export declare type ResolvedRoutesConfig = {
    /**
     * An array of pages to crawl from. The given path must be a valid route such as
     * `/getting-started/` or `/getting-started/intro.html` and a page must match.
     */
    entries: string[];
    /**
     * Route matchers are used to inject pattern matching into file paths. For example, a file path
     * like `[int]/@page.md` has a matcher named `int` which can then be defined at `routes.matchers`
     * in your Vitebook config. The `[int]` will be replaced with the string or Regex you provide.
     * You can provide multiple placeholders for a single file name or path.
     *
     * @example
     * ```js
     * const config = {
     *   routes: {
     *     matchers: [{
     *       name: 'int',
     *       matcher: /\d+/,
     *     }],
     *   },
     * };
     * ```
     */
    matchers: RouteMatcherConfig;
    /**
     * The route logging style.
     *
     * @defaultValue `tree`
     */
    log: RoutesLogStyle;
    /**
     * The route logging level is used by the logger to determine how much detail to include.
     *
     * - `info` - Logs all routes, redirects, and not found pages.
     * - `warn` - Only logs redirects and not found pages.
     * - `error` - Only logs not found pages.
     *
     * @defaultValue `warn`
     */
    logLevel: RoutesLogLevel;
    /**
     * Page routing configuration object.
     */
    pages: {
        /**
         * Globs indicating page files to be included in Vitebook (relative to `<app>`).
         */
        include: string[];
        /**
         * Globs or RegExp indicating page files to be excluded from Vitebook (relative to `<app>`).
         */
        exclude: (string | RegExp)[];
    };
    /**
     * Layouts routing configuration object.
     */
    layouts: {
        /**
         * Globs indicating layout files to be included in Vitebook (relative to `<app>`).
         */
        include: string[];
        /**
         * Globs or RegExp indicating layout files to be excluded from Vitebook (relative to `<app>`).
         */
        exclude: (string | RegExp)[];
    };
    endpoints: {
        /**
         * Globs indicating serverless/edge functions to be included in Vitebook (relative to `<app>`).
         */
        include: string[];
        /**
         * Globs or RegExp indicating serverless/edge functions to be excluded from Vitebook (relative
         * to `<app>`).
         */
        exclude: (string | RegExp)[];
    };
};

export declare type ResolvedSitemapConfig = {
    /**
     * The base url to use when building sitemap URL entries.
     *
     * @example 'http://mysite.com'
     * @defaultValue `null`
     */
    baseUrl: string | null;
    /**
     * Filtern pattern used to determine which HTML pages to include in final sitemap.
     *
     * @defaultValue `.*`
     */
    include: FilterPattern;
    /**
     * Filtern pattern used to determine which HTML pages to exclude from final sitemap.
     *
     * @defaultValue `null`
     */
    exclude: FilterPattern;
    /**
     * Sitemap file name which is output relative to application `<output>` directory.
     *
     * @defaultValue `sitemap.xml`
     */
    filename: string;
    /**
     * How frequently the page is likely to change. This value provides general information to
     * search engines and may not correlate exactly to how often they crawl the page.
     *
     * @defaultValue `'weekly'`
     * @see {@link https://www.sitemaps.org/protocol.html}
     */
    changefreq: SitemapChangeFrequency | ((url: URL) => SitemapChangeFrequency | Promise<SitemapChangeFrequency>);
    /**
     * The priority of this URL relative to other URLs on your site. Valid values range from `0.0` to
     * `1.0`. This value does not affect how your pages are compared to pages on other sites — it
     * only lets the search engines know which pages you deem most important for the crawlers.
     *
     * @defaultValue `0.7`
     * @see {@link https://www.sitemaps.org/protocol.html}
     */
    priority: SitemapPriority | ((url: URL) => SitemapPriority | Promise<SitemapPriority>);
    /**
     * Additional sitemap URLS to be included.
     */
    entries: SitemapURL[];
};

export declare const resolveRelativePath: (base: string, filePath: string) => string;

export declare function resolveRouteFromFilePath(routesDir: string, filePath: string, matchers?: RouteMatcherConfig): RouteInfo;

export declare const resolveRoutePathFromUrl: (url: string, baseUrl?: string) => string;

export declare function resolveStaticRouteFromFilePath(routesDir: string, filePath: string): string;

export declare function rimraf(path: string): void;

export declare type RouteInfo = {
    /** Order number if declared (e.g., `[1]page.md` would be 1). */
    readonly order?: number;
    /**
     * A positive integer representing the path match ranking. The route with the highest score
     * will win if the path matches multiple routes.
     */
    readonly score: number;
    /**
     * `URLPattern` used to match a pattern against a route.
     *
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/URL_Pattern_API}
     */
    readonly pattern: URLPattern;
    /**
     * The pathname used to construct the `URLPattern`.
     */
    readonly pathname: string;
    /**
     * Whether the route pattern is dynamic. This includes wildcards `*`,
     * named groups `/:id`, non-capturing groups `{/path}` and RegExp groups `(\\d+)`.
     *
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/URL_Pattern_API#pattern_syntax}
     */
    readonly dynamic: boolean;
};

export declare type RouteMatcher = string | RegExp | null | undefined | void;

export declare type RouteMatcherConfig = (SimpleRouterMatcher | ComplexRouteMatcher)[];

export declare type RoutesConfig = Partial<Omit<ResolvedRoutesConfig, 'pages' | 'layouts' | 'endpoints'>> & {
    pages?: Partial<ResolvedRoutesConfig['pages']>;
    layouts?: Partial<ResolvedRoutesConfig['layouts']>;
    endpoints?: Partial<ResolvedRoutesConfig['endpoints']>;
};

export declare type RoutesLoggerInput = {
    /** Desired route logging level. */
    level: RoutesLogLevel;
} & BuildData;

export declare type RoutesLogLevel = 'info' | 'warn' | 'error';

export declare type RoutesLogStyle = 'none' | 'list' | 'tree' | CustomRoutesLogger;

export declare function safeNotEqual(a: unknown, b: unknown): {};

export declare type ServerContext = {
    modules: Set<string>;
    data: ServerLoadedDataMap;
};

export declare type ServerEndpoint = ServerFile & {
    /** Routing object. */
    readonly route: RouteInfo;
};

export declare type ServerEntryModule = {
    render: ServerRenderer;
};

export declare type ServerFile = {
    /** Absolute system file path to file.  */
    readonly filePath: string;
    /** System file path relative to `<root>` to associated file. */
    readonly rootPath: string;
};

export declare type ServerLayout = ServerFile & Omit<ClientLayout, 'loader'> & {
    /** Module id used by the client-side router to dynamically load this layout module.  */
    id: string;
    /** The root directory that this layout belongs to. */
    readonly owningDir: string;
    /** Whether the layout has a data `loader` function. */
    hasLoader: boolean;
    /** Whether the current layout resets the layout stack.  */
    reset: boolean;
};

export declare type ServerLoadedData = Record<string, unknown>;

/** Map of data asset id to server loaded data object. */
export declare type ServerLoadedDataMap = Map<string, ServerLoadedData>;

export declare type ServerLoadedOutput<Data = ServerLoadedData> = {
    data?: Data;
    readonly redirect?: string | {
        path: string;
        statusCode?: number;
    };
    readonly cache?: ServerLoaderCacheKeyBuilder;
};

/** Map of data asset id to server loaded output object. */
export declare type ServerLoadedOutputMap = Map<string, ServerLoadedOutput>;

export declare type ServerLoadedRedirect = {
    path: string;
    statusCode: number;
};

export declare type ServerLoader<Data = ServerLoadedData> = (input: ServerLoaderInput) => MaybeServerLoadedOutput<Data> | Promise<MaybeServerLoadedOutput<Data>>;

/** Key can be anything but only truthy values are used to cache. */
export declare type ServerLoaderCacheKey = unknown;

export declare type ServerLoaderCacheKeyBuilder = (input: ServerLoaderInput) => ServerLoaderCacheKey | Promise<ServerLoaderCacheKey>;

export declare type ServerLoaderCacheMap = Map<ServerLoaderCacheKey, ServerLoadedOutput>;

export declare type ServerLoaderInput<Params extends ServerLoaderParams = ServerLoaderParams> = Readonly<{
    pathname: string;
    page: ServerPage;
    route: RouteInfo;
    params: Params;
    /** Result from running `URLPattern.exec().pathname`. */
    match: URLPatternComponentResult;
}>;

export declare type ServerLoaderParams = {
    [param: string]: string | undefined;
};

export declare type ServerPage = ServerFile & Omit<ClientPage, 'loader' | 'layouts'> & {
    /** Module id used by the client-side router to dynamically load this page module.  */
    id: string;
    /** Routing object. */
    readonly route: RouteInfo;
    /** Page layout name. */
    layoutName?: string;
    /**
     * Indentifies layout files that belong to this page. Each number is an index to a layout
     * client layout file in the `layouts` store.
     */
    layouts: number[];
    /**
     * Additional data to be included with the page. This will be included in the client-side
     * response.
     */
    context: Record<string, unknown>;
    /** Whether the page has a data `loader` function. */
    hasLoader: boolean;
};

export declare type ServerRenderer = (url: URL, context: {
    data: ServerContext['data'];
}) => Promise<ServerRenderResult>;

export declare type ServerRenderResult = {
    context: ServerContext;
    head?: string;
    css?: string;
    html: string;
};

export declare type SimpleRouterMatcher = {
    name: string;
    matcher: RouteMatcher;
};

export declare type SitemapChangeFrequency = 'never' | 'yearly' | 'monthly' | 'weekly' | 'daily' | 'hourly' | 'always';

export declare type SitemapConfig = Partial<ResolvedSitemapConfig>;

export declare type SitemapPriority = number;

export declare type SitemapURL = {
    path: string;
    lastmod?: string;
    changefreq?: SitemapChangeFrequency;
    priority?: SitemapPriority;
};

/**
 * Ensure a url `string` has a leading slash `/`.
 */
export declare const slash: (str: string) => string;

/**
 * Split string and keep `/` at the start of each path.
 */
export declare const slashedSplit: (path: string) => string[];

/**
 * Normalize slashes by ensuring a leading slash and no trailing slash.
 */
export declare const slashes: (str: string) => string;

export declare function sortOrderedPageFiles(files: string[]): string[];

export declare function splitRoutePath(pathname: string): string[];

/**
 * `JSON.stringify()` will add quotes `""` around dynamic imports which means they'll be a
 * string, not a dynamic import anymore. This function will strip the quotes to make it a
 * dynamic import again.
 */
export declare function stripImportQuotesFromJson(json: string): string;

export declare const stripImportQuotesRE: RegExp;

export declare function stripPageOrderFromPath(filePath: string): string;

export declare function stripRouteInfoFromFilePath(filePath: string): string;

export declare function stripRouteMetaFromFilePath(filePath: string): string;

export declare function toPascalCase(str: string): string;

export declare function unescapeHTML(str: string): string;

export declare function uppercaseFirstLetter(str: string): string;

export declare type VercelBuildAdapterConfig = {
    /**
     * Whether trailing slashes should be kept or removed. The default behaviour is to remove
     * it (e.g., `foo.com/bar/` becomes `foo.com/bar`).
     *
     * @defaultValue false
     */
    trailingSlash?: boolean;
    /**
     * @see {@link https://vercel.com/docs/build-output-api/v3#vercel-primitives/serverless-functions}
     */
    functions?: {
        /**
         * Specifies which "runtime" will be used to execute the Serverless Function.
         *
         * @defaultValue 'nodejs16.x'
         */
        runtime?: string;
        /**
         * Amount of memory (RAM in MB) that will be allocated to the Serverless Function.
         */
        memory?: number;
        /**
         * Maximum execution duration (in seconds) that will be allowed for the Serverless Function.
         *
         * @defaultValue 3
         */
        maxDuration?: number;
        /**
         * Map of additional environment variables that will be available to the Serverless Function,
         * in addition to the env vars specified in the Project Settings.
         */
        environment?: Record<string, string>[];
        /**
         * List of query string parameter names that will be cached independently. If an empty array,
         * query values are not considered for caching. If undefined each unique query value is cached
         * independently.
         */
        allowQuery?: string[];
        /**
         * List of Vercel Regions where the Serverless Function will be deployed to.
         *
         * @see {@link https://vercel.com/docs/concepts/functions/serverless-functions/regions}
         */
        regions?: string[];
    };
    /**
     * @see {@link https://vercel.com/docs/build-output-api/v3#vercel-primitives/edge-functions/configuration}
     */
    edge?: {
        /**
         * Whether all API endpoints should be output as edge functions.
         *
         * @defaultValue false
         */
        all?: boolean;
        /**
         * List of environment variable names that will be available for the Edge Function to utilize.
         *
         * @defaultValue []
         */
        envVarsInUse?: string[];
    };
};

export declare const virtualAliases: {};

export declare const virtualModuleId: {
    readonly noop: ":virtual/vitebook/noop";
    readonly pages: ":virtual/vitebook/pages";
    readonly layouts: ":virtual/vitebook/layouts";
    readonly client: ":virtual/vitebook/client";
    readonly app: ":virtual/vitebook/app";
};

export declare const virtualModuleRequestPath: {
    readonly noop: "/:virtual/vitebook/noop";
    readonly pages: "/:virtual/vitebook/pages";
    readonly layouts: "/:virtual/vitebook/layouts";
    readonly client: "/:virtual/vitebook/client";
    readonly app: "/:virtual/vitebook/app";
};

export declare type VitebookPlugin = Plugin_2 & {
    vitebook?: {
        /**
         * Whether to run before core Vitebook plugins or after.
         */
        enforce?: 'pre' | 'post';
        /**
         * Overrides client and server entry files.
         */
        entry?: App['entry'];
        /**
         * Hook for extending the Vitebook app configuration.
         */
        config?: (config: ResolvedAppConfig) => Omit<AppConfig, 'dirs'> | null | void | Promise<Omit<AppConfig, 'dirs'> | null | void>;
        /**
         * Called immediately after the config has been resolved.
         */
        configureApp?: (app: App) => void | Promise<void>;
    };
};

declare function vitebookPlugin(config?: VitebookPluginConfig): Plugin_2[];
export default vitebookPlugin;
export { vitebookPlugin as vitebook }

export declare type VitebookPluginConfig = AppConfig;

export declare type VitebookPluginOption = VitebookPlugin | false | null | undefined;

export declare type VitebookPluginOptions = VitebookPluginOption | Promise<VitebookPluginOption> | (VitebookPluginOption | Promise<VitebookPluginOption>)[];

/**
 * Special prefix used throughout Vitebook to identify virtual modules (VM).
 */
export declare const VM_PREFIX: ":virtual/vitebook";

export declare type WithRouteMatch<T> = T & {
    match: URLPatternComponentResult;
};

export { }
