/// <reference types="urlpattern-polyfill" />

export declare type AppContextMap = Map<string, unknown>;

export declare type CancelNavigation = () => void;

export declare type ClientLayout = {
    /** Layout name. */
    readonly name: string;
    /** System file path relative to `<root>`. */
    readonly rootPath: string;
    /** Layout module loader. Used to dynamically import client-side. */
    readonly loader: () => Promise<ClientLayoutModule>;
};

export declare type ClientLayoutModule = ClientPageModule;

export declare type ClientLoadedData = Record<string, unknown>;

export declare type ClientPage = {
    /** System file path relative to `<root>`. */
    readonly rootPath: string;
    /** Page route object. */
    readonly route: RouteInfo;
    /** Page file extension.  */
    readonly ext: string;
    /** Additional page metadata. */
    readonly context?: Record<string, unknown>;
    /** Page layout name. */
    readonly layoutName?: string;
    /** Page layouts identifiers. */
    readonly layouts: number[];
    /** Page module loader. Used to dynamically import page module client-side. */
    readonly loader: () => Promise<ClientPageModule>;
};

export declare type ClientPageModule = {
    readonly [id: string]: unknown;
    readonly default: unknown;
    readonly meta?: MarkdownMeta;
    readonly loader?: ServerLoader;
};

export declare type ComplexRouteMatcher = (route: string, info: {
    filePath: string;
}) => string | null | undefined | void;

export declare type ConfigureApp = (app: {
    context: AppContextMap;
    router: Router;
    renderers: ViewRenderer[];
}) => void | Promise<void>;

export declare type ContextTypes = {
    [SERVER_CTX_KEY]: ServerContext;
    [RENDERERS_CTX_KEY]: ViewRenderer[];
    [ROUTER_CTX_KEY]: Router;
    [ROUTE_CTX_KEY]: RouteStore;
    [PAGE_CTX_KEY]: PageStore;
    [MARKDOWN_CTX_KEY]: MarkdownStore;
    [FRONTMATTER_CTX_KEY]: FrontmatterStore;
};

export declare const createFrontmatterStore: (markdown: MarkdownStore) => FrontmatterStore;

export declare const createMarkdownStore: (page: PageStore) => MarkdownStore;

export declare function createMemoryHistory(): MemoryHistory;

export declare const createPageStore: () => PageStore;

export declare const createRouteStore: () => RouteStore;

/**
 * Derived value store by synchronizing one or more readable stores and
 * applying an aggregation function over its input values.
 */
export declare function derived<S extends Stores, T>(stores: S, fn: (values: StoresValues<S>, set: (value: T) => void) => StoreUnsubscriber | void, initialValue?: T): ReadableStore<T>;

/**
 * Derived value store by synchronizing one or more readable stores and
 * applying an aggregation function over its input values.
 */
export declare function derived<S extends Stores, T>(stores: S, fn: (values: StoresValues<S>) => T, initialValue?: T): ReadableStore<T>;

/**
 * Derived value store by synchronizing one or more readable stores and
 * applying an aggregation function over its input values.
 */
export declare function derived<S extends Stores, T>(stores: S, fn: (values: StoresValues<S>) => T): ReadableStore<T>;

export declare function findViewRenderer(id: string, module: ViewModule, renderers: ViewRenderer[]): ViewRenderer | undefined;

export declare const FRONTMATTER_CTX_KEY = "vitebook::frontmatter";

export declare type FrontmatterStore = ReadableStore<MarkdownMeta['frontmatter']>;

export declare function get<T>(store: ReadableStore<T>): T;

export declare function getContext<T extends keyof ContextTypes>(context: AppContextMap, key: T): ContextTypes[T];

export declare type GoToRouteOptions = {
    scroll?: ScrollToTarget | null;
    keepfocus?: boolean;
    replace?: boolean;
    state?: any;
};

export declare function initAppContext(): Map<any, any>;

export declare const layouts: ReadableStore<ClientLayout[]>;

export declare type LoadedClientLayout = ClientLayout & {
    readonly $$loaded: true;
    readonly module: ClientLayoutModule;
    readonly default: unknown;
    readonly data: ClientLoadedData;
};

export declare type LoadedClientMarkdownPage = LoadedClientPage & {
    readonly meta: MarkdownMeta;
};

export declare type LoadedClientPage = Omit<ClientPage, 'layouts'> & {
    readonly $$loaded: true;
    readonly module: ClientPageModule;
    readonly default: unknown;
    readonly layouts: LoadedClientLayout[];
    readonly data: ClientLoadedData;
};

export declare type LoadedRoute = Route & {
    page: LoadedClientPage;
};

export declare const MARKDOWN_CTX_KEY = "vitebook::markdown";

export declare type MarkdownFrontmatter = Record<string, any>;

export declare type MarkdownHeading = {
    level: number;
    title: string;
    id: string;
};

export declare type MarkdownMeta = {
    title?: string | null;
    headings: MarkdownHeading[];
    frontmatter: MarkdownFrontmatter;
    lastUpdated: number;
};

export declare type MarkdownStore = ReadableStore<MarkdownMeta | undefined>;

export declare type MaybeServerLoadedOutput<Data = ServerLoadedData> = void | undefined | null | ServerLoadedOutput<Data>;

/** Used server-side.  */
export declare class MemoryHistory implements History {
    scrollRestoration: ScrollRestoration;
    protected history: string[];
    protected position: number;
    protected _state: {};
    get state(): {};
    get length(): number;
    back(): void;
    forward(): void;
    go(delta: number): void;
    pushState(data: any, _: string, url?: string | URL | null): void;
    replaceState(state: any, _: string, url?: string | URL | null): void;
    protected setLocation(location: string): void;
}

export declare type NavigationOptions = GoToRouteOptions & {
    accepted?: () => void;
    blocked?: () => void;
};

export declare const PAGE_CTX_KEY = "vitebook::page";

export declare const pages: ReadableStore<ClientPage[]>;

export declare type PageStore = {
    subscribe: WritableStore<LoadedClientPage>['subscribe'];
    __update: WritableStore<LoadedClientPage>['update'];
    __set: WritableStore<LoadedClientPage>['set'];
};

/**
 * Creates a `Readable` store that allows reading by subscription.
 */
export declare function readable<T>(value?: T, start?: StoreStartStopNotifier<T>): ReadableStore<T>;

/** Readable interface for subscribing. */
export declare type ReadableStore<T> = {
    /**
     * Subscribe on value changes.
     * @param run - subscription callback
     * @param invalidate - cleanup callback
     */
    subscribe(this: void, run: StoreSubscriber<T>, invalidate?: StoreInvalidator<T>): StoreUnsubscriber;
};

export declare type ReadableStoreRecord = {
    [prop: string]: ReadableStore<any>;
};

export declare type RedirectRoute = (pathnameOrURL: string | URL) => void;

export declare const RENDERERS_CTX_KEY = "vitebook::renderers";

export declare type Route = RouteDeclaration & {
    readonly id: string;
    readonly url: URL;
    readonly match: URLPatternComponentResult;
};

export declare const ROUTE_CTX_KEY = "vitebook::route";

export declare type RouteDeclaration = Omit<RouteInfo, 'score'> & {
    score?: number;
    prefetch?: RoutePrefetch;
    loader: RouteLoader;
};

export declare type RouteInfo = {
    /** Order number if declared (e.g., `[1]page.md` would be 1). */
    readonly order?: number;
    /**
     * A positive integer representing the path match ranking. The route with the highest score
     * will win if the path matches multiple routes.
     */
    readonly score: number;
    /**
     * `URLPattern` used to match a pattern against a route.
     *
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/URL_Pattern_API}
     */
    readonly pattern: URLPattern;
    /**
     * The pathname used to construct the `URLPattern`.
     */
    readonly pathname: string;
    /**
     * Whether the route pattern is dynamic. This includes wildcards `*`,
     * named groups `/:id`, non-capturing groups `{/path}` and RegExp groups `(\\d+)`.
     *
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/URL_Pattern_API#pattern_syntax}
     */
    readonly dynamic: boolean;
};

export declare type RouteLoader = (info: {
    route: Route;
    redirect: RedirectRoute;
}) => void | LoadedClientPage | Promise<void | LoadedClientPage>;

export declare type RouteMatcher = string | RegExp | null | undefined | void;

export declare type RouteMatcherConfig = (SimpleRouterMatcher | ComplexRouteMatcher)[];

export declare type RouteNavigation = {
    from: URL;
    to: URL;
} | null;

export declare type RoutePrefetch = (info: {
    url: URL;
    route: Route;
    redirect: RedirectRoute;
}) => void | Promise<void>;

export declare class Router {
    protected _url: URL;
    protected _started: boolean;
    protected _currentRoute: LoadedRoute | null;
    protected _routes: ScoredRouteDeclaration[];
    protected readonly _history: History;
    protected readonly _redirects: Map<string, string>;
    protected _historyIndex: number;
    protected readonly _historyIndexKey = "vitebook::index";
    protected readonly _scrollKey = "vitebook:scroll";
    protected readonly _scrollPositions: Record<string, {
        top: number;
        left: number;
    }>;
    protected readonly _navigation: WritableStore<RouteNavigation>;
    /**
     * The DOM node on which routes will be mounted on.
     */
    readonly target: HTMLElement | null;
    /**
     * Application context that's passed to the route handler.
     */
    readonly context: AppContextMap;
    /**
     * Whether the router is disabled. Disabling the router means the browser will handle all
     * navigation and calling `goto` will be a no-op.
     *
     * @defaultValue `false`
     */
    disabled: boolean;
    /**
     * The base URL for all routes.
     *
     * @defaultValue `'/'`
     */
    readonly baseUrl: string;
    /**
     * Indicates how the browser should scroll when navigating to a new page.
     *
     * @defaultValue `'auto'`
     */
    scrollBehavior?: RouterScrollBehaviorHook;
    /**
     * Base scroll settings that are applied to all scrolls.
     */
    scrollBase?: () => RouterScrollBase;
    _beforeNavigate: RouterBeforeNavigateHook[];
    /**
     * Called when navigating to a new route and right before a new page is loaded. Returning a
     * redirect path will navigate to the matching route declaration.
     *
     * @defaultValue undefined
     */
    beforeNavigate(hook: RouterBeforeNavigateHook): void;
    _afterNavigate: RouterAfterNavigateHook[];
    /**
     * Called after navigating to a new route and it's respective page has loaded.
     *
     * @defaultValue undefined
     */
    afterNavigate(hook: RouterAfterNavigateHook): void;
    /**
     * The current URL.
     */
    get url(): URL;
    /**
     * Route navigation store.
     */
    get navigation(): ReadableStore<RouteNavigation>;
    /**
     * Whether the router is in the process of navigating to another page.
     */
    get navigating(): boolean;
    /**
     * Whether the router has started (i.e., loaded first page).
     */
    get started(): boolean;
    /**
     * The currently loaded route.
     */
    get currentRoute(): LoadedRoute | null;
    constructor({ target, context, baseUrl, history, routes }: RouterOptions);
    /**
     * Redirect from a given pathname to another.
     */
    addRedirect(from: string | URL, to: string | URL): void;
    /**
     * Returns a route declaration given a URL pathname such as `/` or `/getting-started/intro.html`.
     */
    getRoute(pathname: string): WithRouteMatch<ScoredRouteDeclaration> | undefined;
    /**
     * Returns whether the given pathname matches any route.
     */
    hasRoute(pathnameOrRoute: string | RouteDeclaration): boolean;
    /**
     * Registers a new route given a declaration.
     */
    addRoute(route: RouteDeclaration): void;
    /**
     * Deregisters a route given it's declaration.
     */
    removeRoute(route: RouteDeclaration): void;
    /**
     * Builds and returns an application URL given a pathname.
     */
    buildURL(pathnameOrURL: string | URL): URL;
    /**
     * Checks whether the given URL belongs to this application.
     */
    owns(url: URL): boolean;
    /**
     * Attempts to find, build, and return a `Route` object given a pathname or URL.
     */
    findRoute(pathnameOrURL: string | URL): WithRouteMatch<Route> | null;
    /**
     * Navigate to the previous page.
     */
    back(): void;
    /**
     * Attempts to match the given path to a declared route and navigate to it. The path can be a
     * URL pathname (e.g., `/a/path.html`), hash (e.g., `#some-id`), or URL instance (e.g., `new URL(...)`).
     */
    go(path: string | URL, { scroll, replace, keepfocus, state, }?: GoToRouteOptions): Promise<void>;
    /**
     * Loads `href` the old-fashioned way, with a full page reload. Returns a `Promise` that never
     * resolves to prevent any subsequent work (e.g., history manipulation).
     */
    goLocation(url: URL): Promise<void>;
    /**
     * Attempts to find a route given a pathname or URL and call it's prefetch handler. This method
     * will throw if no route matches the given pathname.
     */
    prefetch(pathnameOrURL: string | URL): Promise<void>;
    protected _redirect(url: URL, handle: (url: URL) => Promise<void>): null | Promise<void>;
    protected _buildRedirect(from: string | URL, handleRedirect: (url: URL) => void | Promise<void>): RedirectRoute;
    protected _navigate(url: URL, { scroll, accepted, blocked, state, keepfocus, replace, }: NavigationOptions): Promise<void>;
    protected _changeHistoryState(url: URL, state: any, replace: boolean): void;
    protected _updateHash(hash: string): void;
    protected _updateScrollPosition(): void;
    protected _scroll({ scroll, hash, from, to, }: {
        hash?: string;
        from?: LoadedRoute | null;
        to?: LoadedRoute;
        scroll?: ScrollToTarget | null;
    }): Promise<void>;
    listen(): void;
}

export declare const ROUTER_CTX_KEY = "vitebook::router";

export declare type RouterAfterNavigateHook = (navigation: {
    from: LoadedRoute | null;
    to: LoadedRoute;
    match: URLPatternComponentResult;
}) => void | Promise<void>;

export declare type RouterBeforeNavigateHook = (navigation: {
    from: LoadedRoute | null;
    to: WithRouteMatch<RouteDeclaration>;
    match: URLPatternComponentResult;
    cancel: CancelNavigation;
    redirect: RedirectRoute;
}) => void;

export declare type RouterOptions = {
    target: HTMLElement | null;
    context: AppContextMap;
    baseUrl: string;
    history: History;
    routes?: RouteDeclaration[];
};

export declare type RouterScrollBase = ScrollToOptions;

export declare type RouterScrollBehaviorHook = (info: {
    from: LoadedRoute | null;
    to: LoadedRoute;
    cancel: ScrollCancel;
    savedPosition?: {
        top?: number;
        left?: number;
    };
}) => ScrollTarget | Promise<ScrollTarget>;

export declare type RouteStore = {
    subscribe: WritableStore<LoadedRoute>['subscribe'];
    __update: WritableStore<LoadedRoute>['update'];
    __set: WritableStore<LoadedRoute>['set'];
};

export declare type ScoredRouteDeclaration = RouteDeclaration & {
    readonly score: number;
};

export declare type ScrollCancel = () => void;

export declare type ScrollTarget = void | null | false | (ScrollToOptions & {
    el?: string | HTMLElement;
});

export declare type ScrollToTarget = (info: {
    cancel: ScrollCancel;
}) => ScrollTarget;

export declare const SERVER_CTX_KEY = "vitebook::server";

export declare type ServerContext = {
    modules: Set<string>;
    data: ServerLoadedDataMap;
};

export declare type ServerEndpoint = ServerFile & {
    /** Routing object. */
    readonly route: RouteInfo;
};

export declare type ServerEntryModule = {
    render: ServerRenderer;
};

export declare type ServerFile = {
    /** Absolute system file path to file.  */
    readonly filePath: string;
    /** System file path relative to `<root>` to associated file. */
    readonly rootPath: string;
};

export declare type ServerLayout = ServerFile & Omit<ClientLayout, 'loader'> & {
    /** Module id used by the client-side router to dynamically load this layout module.  */
    id: string;
    /** The root directory that this layout belongs to. */
    readonly owningDir: string;
    /** Whether the layout has a data `loader` function. */
    hasLoader: boolean;
    /** Whether the current layout resets the layout stack.  */
    reset: boolean;
};

export declare type ServerLoadedData = Record<string, unknown>;

/** Map of data asset id to server loaded data object. */
export declare type ServerLoadedDataMap = Map<string, ServerLoadedData>;

export declare type ServerLoadedOutput<Data = ServerLoadedData> = {
    data?: Data;
    readonly redirect?: string | {
        path: string;
        statusCode?: number;
    };
    readonly cache?: ServerLoaderCacheKeyBuilder;
};

/** Map of data asset id to server loaded output object. */
export declare type ServerLoadedOutputMap = Map<string, ServerLoadedOutput>;

export declare type ServerLoadedRedirect = {
    path: string;
    statusCode: number;
};

export declare type ServerLoader<Data = ServerLoadedData> = (input: ServerLoaderInput) => MaybeServerLoadedOutput<Data> | Promise<MaybeServerLoadedOutput<Data>>;

/** Key can be anything but only truthy values are used to cache. */
export declare type ServerLoaderCacheKey = unknown;

export declare type ServerLoaderCacheKeyBuilder = (input: ServerLoaderInput) => ServerLoaderCacheKey | Promise<ServerLoaderCacheKey>;

export declare type ServerLoaderCacheMap = Map<ServerLoaderCacheKey, ServerLoadedOutput>;

export declare type ServerLoaderInput<Params extends ServerLoaderParams = ServerLoaderParams> = Readonly<{
    pathname: string;
    page: ServerPage;
    route: RouteInfo;
    params: Params;
    /** Result from running `URLPattern.exec().pathname`. */
    match: URLPatternComponentResult;
}>;

export declare type ServerLoaderParams = {
    [param: string]: string | undefined;
};

export declare type ServerPage = ServerFile & Omit<ClientPage, 'loader' | 'layouts'> & {
    /** Module id used by the client-side router to dynamically load this page module.  */
    id: string;
    /** Routing object. */
    readonly route: RouteInfo;
    /** Page layout name. */
    layoutName?: string;
    /**
     * Indentifies layout files that belong to this page. Each number is an index to a layout
     * client layout file in the `layouts` store.
     */
    layouts: number[];
    /**
     * Additional data to be included with the page. This will be included in the client-side
     * response.
     */
    context: Record<string, unknown>;
    /** Whether the page has a data `loader` function. */
    hasLoader: boolean;
};

export declare type ServerRenderer = (url: URL, context: {
    data: ServerContext['data'];
}) => Promise<ServerRenderResult>;

export declare type ServerRenderResult = {
    context: ServerContext;
    head?: string;
    css?: string;
    html: string;
};

export declare type SimpleRouterMatcher = {
    name: string;
    matcher: RouteMatcher;
};

/** Cleanup logic callback. */
export declare type StoreInvalidator<T> = (value?: T) => void;

/** One or more `Readable`s. */
export declare type Stores = ReadableStore<any> | [ReadableStore<any>, ...Array<ReadableStore<any>>] | Array<ReadableStore<any>>;

/** Start and stop notification callbacks. */
export declare type StoreStartStopNotifier<T> = (set: StoreSubscriber<T>) => StoreUnsubscriber | void;

/** Callback to inform of a value updates. */
export declare type StoreSubscriber<T> = (value: T) => void;

/** One or more values from `Readable` stores. */
export declare type StoresValues<T> = T extends ReadableStore<infer U> ? U : {
    [K in keyof T]: T[K] extends ReadableStore<infer U> ? U : never;
};

/** Unsubscribes from value updates. */
export declare type StoreUnsubscriber = () => void;

/** Callback to update a value. */
export declare type StoreUpdater<T> = (value: T) => T;

export declare type StoreValue<T> = T extends ReadableStore<infer U> ? U : never;

/** Pair of subscriber and invalidator. */
export declare type SubscribeInvalidateTuple<T> = [
StoreSubscriber<T>,
StoreInvalidator<T>
];

export declare type ViewModule = {
    readonly [id: string]: unknown;
};

export declare type ViewRenderer<ClientModule extends ViewModule = ViewModule, ServerModule extends ViewModule = ViewModule> = {
    name: string;
    attach(options: {
        target: HTMLElement;
        context: AppContextMap;
        module: ClientModule;
        hydrate: boolean;
    }): void | Promise<void>;
    detach(options: {
        target: HTMLElement;
    }): void | Promise<void>;
    canRender(id: string, module: ViewModule): boolean;
    ssr(options: {
        module: ServerModule;
        context: AppContextMap;
    }): Omit<ServerRenderResult, 'context'> | Promise<Omit<ServerRenderResult, 'context'>>;
};

export declare type WithRouteMatch<T> = T & {
    match: URLPatternComponentResult;
};

/**
 * Create a `Writable` store that allows both updating and reading by subscription.
 */
export declare function writable<T>(value?: T, start?: StoreStartStopNotifier<T>): WritableStore<T>;

/** Writable interface for both updating and subscribing. */
export declare type WritableStore<T> = ReadableStore<T> & {
    /**
     * Set value and inform subscribers.
     * @param value - to set
     */
    set(this: void, value: T): void;
    /**
     * Update value using callback and inform subscribers.
     * @param updater - callback
     */
    update(this: void, updater: StoreUpdater<T>): void;
};

export declare type WritableStoreRecord = {
    [prop: string]: WritableStore<any>;
};

export { }
